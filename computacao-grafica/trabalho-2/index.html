<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - Primitives</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
      }
      p {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        color: yellow;
        font-size: 28px;
        text-align: center;
      }
      #cid {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>

  <body>
    <p>Utilize o mouse para girar a camera e o scroll para controlar o zoom</p>
    <canvas id="cid"></canvas>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.163.0/build/three.module.js'

      import {
        OrbitControls
      } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/OrbitControls.js'
      import {
        ParametricGeometry
      } from 'https://unpkg.com/three@0.163.0/examples/jsm/geometries/ParametricGeometry.js'
      import {
        FontLoader
      } from 'https://unpkg.com/three@0.163.0/examples/jsm/loaders/FontLoader.js'
      import {
        TextGeometry
      } from 'https://unpkg.com/three@0.163.0/examples/jsm/geometries/TextGeometry.js'

      const canvas = document.querySelector('#cid')
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          canvas
        })
        renderer.setSize(window.innerWidth, window.innerHeight)

        // Configurações da camera
        const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.z = 150

        // Configurando a interação do movimento da camera
        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.25
        controls.rotateSpeed = 0.5

        // Configurações da cena
        const scene = new THREE.Scene()
        scene.background = new THREE.Color(0x000000)

        // Configurações da luz ambiente
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
        scene.add(ambientLight)

        // Array para guardar formas
        const objects = []
        const lights = []

        // Tamanho
        const spread = 15

        // Adicionar um objeto
        function addObject(geometry, material, position) {
          const obj = new THREE.Mesh(geometry, material)
          obj.rotation.set(Math.PI / 10, Math.PI / 5, 0)
          obj.position.set(position.x * spread, position.y * spread, position.z * spread)
          scene.add(obj)
          objects.push(obj)
        }

        // ############### Objeto 1 ###############
        {
          const outline = new THREE.Shape([
            [ -2, -0.1], [  2, -0.1], [ 2,  0.6],
            [1.6,  0.6], [1.6,  0.1], [-2,  0.1],
          ].map(p => new THREE.Vector2(...p)))

          const x = -2.5
          const y = -5
          const shape = new THREE.CurvePath()
          const points = [
            [x + 2.5, y + 2.5],
            [x + 2.5, y + 2.5], [x + 2,   y      ], [x,       y      ],
            [x - 3,   y      ], [x - 3,   y + 3.5], [x - 3,   y + 3.5],
            [x - 3,   y + 5.5], [x - 1.5, y + 7.7], [x + 2.5, y + 9.5],
            [x + 6,   y + 7.7], [x + 8,   y + 4.5], [x + 8,   y + 3.5],
            [x + 8,   y + 3.5], [x + 8,   y      ], [x + 5,   y      ],
            [x + 3.5, y      ], [x + 2.5, y + 2.5], [x + 2.5, y + 2.5],
          ].map(p => new THREE.Vector3(...p, 0))
          for (let i = 0; i < points.length; i += 3) {
            shape.add(new THREE.CubicBezierCurve3(...points.slice(i, i + 4)))
          }
          const extrudeSettings = {
            steps:  13,
            bevelEnabled: false,
            extrudePath: shape,
          }

          const geometry = new THREE.ExtrudeGeometry(outline, extrudeSettings)
          const material = new THREE.MeshPhongMaterial({ color: 0xffffff, wireframe: true })
          addObject(geometry, material, { x: -2, y: -2, z: -2 })
        }

        // ############### Objeto 2 ###############
        {
          function klein(v, u, target) {
            u *= Math.PI
            v *= 2 * Math.PI
            u = u * 2
            let x
            let z
            if (u < Math.PI) {
              x =
                3 * Math.cos(u) * (1 + Math.sin(u)) +
                2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v)
              z = -8 * Math.sin(u) -
                2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v)
            } else {
              x =
                3 * Math.cos(u) * (1 + Math.sin(u)) +
                2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI)
              z = -8 * Math.sin(u)
            }
            const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v)
            target.set(x, y, z).multiplyScalar(0.75)
          }
          const slices = 25
          const stacks = 25

          const geometry = new ParametricGeometry(klein, slices, stacks)
          const material = new THREE.MeshPhongMaterial({ color: 0xffffff })
          addObject(geometry, material, { x: -1, y: -1, z: -1 })
        }

        // ############### Objeto 3 ###############
        {
          async function exec() {
            // Promise para carregamento
            function loadFont(url) {
              return new Promise((resolve, reject) => {
                new FontLoader().load(url, resolve, undefined, reject)
              })
            }

            const font = await loadFont(
              'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json'
            )
            const geometry = new TextGeometry('Computacao Grafica', {
              font: font,
              size:  3,
              depth:  2,
              curveSegments:  1,
              bevelEnabled: false,
              bevelThickness: 0.15,
              bevelSize: 0.10,
              bevelSegments: 4,
            })

            const material = new THREE.MeshNormalMaterial()
            const mesh = new THREE.Mesh(geometry, material)
            const parent = new THREE.Object3D()
            geometry.computeBoundingBox()
            geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1)
            parent.add(mesh)

            parent.position.x = 0 * spread
            parent.position.y = 0 * spread
            scene.add(parent)
            objects.push(parent)
          }
          exec()
        }

        // ############### Objeto 4 ###############
        {
          const radius = 5
          const tubeRadius = 2
          const radialSegments = 8
          const tubularSegments = 24

          const geometry = new THREE.TorusGeometry(radius, tubeRadius, radialSegments, tubularSegments)
          const material = new THREE.MeshLambertMaterial({ color: 0x00a2ff, emissive: 0xff0000 })
          addObject(geometry, material, { x: 1, y: 1, z: 1 })
        }

        // ############### Objeto 5 ###############
        {
          const radius = 3.5
          const tube = 1.5
          const radialSegments = 8
          const tubularSegments = 64
          const p = 6
          const q = 3

          const geometry = new THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q)
          const material = new THREE.MeshPhongMaterial({ color: 0x00a2ff, emissive: 0xff0000 })
          addObject(geometry, material, { x: 2, y: 2, z: 2 })
        }

        // Configurações das luzes direcionais
        {
          const directionalLight1 = new THREE.DirectionalLight(0xff0000, 3)
          directionalLight1.position.set(-3, -3, 0.5)
          scene.add(directionalLight1)
          lights.push(directionalLight1)
        }

        {
          const directionalLight2 = new THREE.DirectionalLight(0x00ff00, 3)
          directionalLight2.position.set(0, 0, 0.5)
          scene.add(directionalLight2)
          lights.push(directionalLight2)
        }

        {
          const directionalLight3 = new THREE.DirectionalLight(0x0000ff, 3)
          directionalLight3.position.set(3, 3, 0.5)
          scene.add(directionalLight3)
          lights.push(directionalLight3)
        }

        // Animação de giro
        function rotationAnimation(time) {
          time *= 0.001
          objects.forEach((obj, index) => {
            if (index == 0) {
              obj.rotation.x = -time
              obj.rotation.y = time
              obj.rotation.z = time
            }
            if (index == 1) {
              obj.rotation.x = time
              obj.rotation.y = -time
              obj.rotation.z = time
            }
            if (index == 2) {
              obj.rotation.x = time
              obj.rotation.y = time
              obj.rotation.z = -time
            }
            if (index == 3) {
              obj.rotation.x = time
              obj.rotation.y = time
              obj.rotation.z = -time
            }
            if (index == 4) {
              obj.rotation.x = time
              obj.rotation.y = time
              obj.rotation.z = -time
            }
          })
        }

        // Renderizando a cena
        function render(time) {
          // Animação
          rotationAnimation(time)

          renderer.render(scene, camera)
          controls.update()
          requestAnimationFrame(render)
        }

        render()

      function main() {
        // Configurações da cena

      }

      main()
    </script>
  </body>
</html>
